import fs from 'fs/promises';
import path from 'path';
import { InstalledPlugin } from '../models/InstalledPlugin';
import { pluginLoaderService } from './pluginLoaderService';

/**
 * Servicio para crear bundles de plugins que pueden ser cargados en el frontend
 */
export class PluginBundleService {
  /**
   * Genera un bundle JavaScript para un plugin que puede ser cargado en el frontend
   */
  async generatePluginBundle(plugin: InstalledPlugin): Promise<string> {
    console.log(`üîß Generating bundle for plugin: ${plugin.slug}`);
    
    const pluginDir = pluginLoaderService.getPluginDirectory(plugin.id);
    
    if (!pluginDir) {
      console.error(`‚ùå Plugin ${plugin.slug} not loaded - no directory found`);
      throw new Error('Plugin not loaded');
    }

    console.log(`   Plugin directory: ${pluginDir}`);

    // Para Task Manager, crear un bundle simple que exporte el manifest y las rutas
    if (plugin.slug === 'task-manager') {
      return this.generateTaskManagerBundle(plugin, pluginDir);
    }

    // Para otros plugins, generar bundle gen√©rico
    return this.generateGenericBundle(plugin, pluginDir);
  }

  /**
   * Genera el bundle para Task Manager
   */
  private async generateTaskManagerBundle(plugin: InstalledPlugin, pluginDir: string): Promise<string> {
    const manifest = plugin.manifest;

    // Leer los componentes compilados y obtener la lista de nombres
    const componentsResult = await this.loadPluginComponents(pluginDir, manifest);
    const storeCode = await this.loadPluginStore(pluginDir, manifest);

    // Extraer nombres de componentes exportados
    const componentNames = this.extractComponentNames(componentsResult.code);
    const componentsObject = componentNames.length > 0 
      ? `{ ${componentNames.join(', ')} }` 
      : '{}';

    // Crear un m√≥dulo JavaScript que el frontend puede importar
    const bundle = `
// Task Manager Plugin Bundle
// Auto-generated by PluginBundleService

// Placeholder component generator
function createPlaceholderComponent(componentName) {
  // Retornar un objeto de componente Vue simple
  return {
    name: componentName,
    template: \`
      <div class="flex items-center justify-center min-h-screen bg-gray-900">
        <div class="text-center p-8 bg-gray-800 rounded-lg shadow-xl max-w-2xl">
          <div class="text-6xl mb-4">üöß</div>
          <h2 class="text-2xl font-bold text-white mb-4">Plugin System in Development</h2>
          <p class="text-gray-400 mb-6">
            The dynamic plugin loading system is currently being developed.
            Vue component compilation at runtime requires a more sophisticated build system.
          </p>
          <div class="bg-gray-700 p-4 rounded text-left">
            <p class="text-sm text-gray-300 mb-2">Component: \${componentName}</p>
            <p class="text-sm text-gray-300 mb-2">Plugin: ${plugin.name}</p>
            <p class="text-sm text-gray-300">Version: ${plugin.version}</p>
          </div>
          <p class="text-gray-500 text-sm mt-6">
            This feature will be available in a future update.
          </p>
        </div>
      </div>
    \`.replace(/\\\${componentName}/g, componentName)
  };
}

// Funci√≥n alternativa usando render function sin imports
function createPlaceholderComponentAlt(componentName) {
  return {
    name: componentName,
    data() {
      return { componentName }
    },
    template: \`<div class="flex items-center justify-center min-h-screen bg-gray-900"><div class="text-center p-8 bg-gray-800 rounded-lg shadow-xl max-w-2xl"><div class="text-6xl mb-4">üöß</div><h2 class="text-2xl font-bold text-white mb-4">Plugin System in Development</h2><p class="text-gray-400 mb-6">The dynamic plugin loading system is currently being developed.</p><div class="bg-gray-700 p-4 rounded text-left"><p class="text-sm text-gray-300 mb-2">Component: {{ componentName }}</p><p class="text-sm text-gray-300 mb-2">Plugin: ${plugin.name}</p><p class="text-sm text-gray-300">Version: ${plugin.version}</p></div></div></div>\`
  };
}


export const pluginInfo = {
  id: '${plugin.id}',
  slug: '${plugin.slug}',
  name: '${plugin.name}',
  version: '${plugin.version}',
  description: '${plugin.description || ''}',
  manifest: ${JSON.stringify(manifest, null, 2)}
};

// Rutas del plugin
export const routes = ${JSON.stringify(manifest.frontend?.routes || [], null, 2)};

// ============================================
// COMPONENTES DEL PLUGIN
// ============================================

${componentsResult.code}

// Objeto de componentes para export
export const components = ${componentsObject};

// ============================================
// STORE DEL PLUGIN
// ============================================

${storeCode}

// Funci√≥n de inicializaci√≥n
export async function initialize() {
  console.log('üìã Task Manager Plugin initialized');
  return true;
}

// Funci√≥n de limpieza
export async function destroy() {
  console.log('üìã Task Manager Plugin destroyed');
  return true;
}

export default {
  pluginInfo,
  routes,
  components,
  store: useTaskStore,
  initialize,
  destroy
};
`;

    console.log(`   Bundle generated with ${componentNames.length} components`);
    return bundle;
  }

  /**
   * Genera un bundle gen√©rico para cualquier plugin
   */
  private async generateGenericBundle(plugin: InstalledPlugin, pluginDir: string): Promise<string> {
    const manifest = plugin.manifest;

    const bundle = `
// ${plugin.name} Plugin Bundle
// Auto-generated by PluginBundleService

export const pluginInfo = {
  id: '${plugin.id}',
  slug: '${plugin.slug}',
  name: '${plugin.name}',
  version: '${plugin.version}',
  description: '${plugin.description || ''}',
  manifest: ${JSON.stringify(manifest, null, 2)}
};

export const routes = ${JSON.stringify(manifest.frontend?.routes || [], null, 2)};

export const components = {};

export async function initialize() {
  console.log('üì¶ ${plugin.name} Plugin initialized');
  return true;
}

export async function destroy() {
  console.log('üì¶ ${plugin.name} Plugin destroyed');
  return true;
}

export default {
  pluginInfo,
  routes,
  components,
  initialize,
  destroy
};
`;

    return bundle;
  }

  /**
   * Carga y concatena todos los componentes del plugin
   */
  private async loadPluginComponents(pluginDir: string, manifest: any): Promise<{ code: string, names: string[] }> {
    console.log(`   Loading components from: ${pluginDir}`);
    const componentsExports: string[] = [];
    const componentNames: string[] = [];
    
    // Cargar views - usar placeholders por ahora
    if (manifest.frontend?.routes) {
      console.log(`   Found ${manifest.frontend.routes.length} routes in manifest`);
      for (const route of manifest.frontend.routes) {
        const componentPath = route.component;
        if (componentPath) {
          const componentName = path.basename(componentPath, '.vue');
          componentsExports.push(`export const ${componentName} = createPlaceholderComponentAlt('${componentName}');`);
          componentNames.push(componentName);
          console.log(`   ‚úì Created placeholder for: ${componentName}`);
        }
      }
    }

    // Cargar components adicionales - usar placeholders
    if (manifest.frontend?.components) {
      for (const [name, componentPath] of Object.entries(manifest.frontend.components)) {
        componentsExports.push(`export const ${name} = createPlaceholderComponentAlt('${name}');`);
        componentNames.push(name);
        console.log(`   ‚úì Created placeholder for: ${name}`);
      }
    }

    console.log(`   Total components exported: ${componentNames.length}`);
    return {
      code: componentsExports.join('\n'),
      names: componentNames
    };
  }

  /**
   * Extrae los nombres de componentes del c√≥digo generado
   */
  private extractComponentNames(code: string): string[] {
    const names: string[] = [];
    const exportRegex = /export const (\w+) =/g;
    let match;
    while ((match = exportRegex.exec(code)) !== null) {
      names.push(match[1]);
    }
    return names;
  }

  /**
   * Carga el store del plugin
   */
  private async loadPluginStore(pluginDir: string, manifest: any): Promise<string> {
    // Por ahora, deshabilitar stores hasta que tengamos un sistema de build completo
    // Los stores requieren pinia que no est√° disponible en el bundle
    return '// Store disabled - requires proper build system\nexport const useTaskStore = null;';
  }

  /**
   * Obtiene la URL del bundle de un plugin
   */
  getPluginBundleUrl(pluginSlug: string): string {
    return `/api/plugin-bundles/${pluginSlug}/bundle.js`;
  }
}

export const pluginBundleService = new PluginBundleService();

